{"entries":[{"id":"jtLQeq","title":"Svelte is not a javascript framework","body":"...and that is what makes it so good!\n\nAlthough Svelte is often mentioned in the same breath as javascript frameworks like React and Vuejs, Svelte actually works more like a compiler. Where React and Vue interpret your code at runtime (requiring every visitor to load the full library), Svelte does the heavy lifting up front by compiling your code into optimized vanilla javascript. No client-side dependancies.\n\nAnother big difference is that while Vue and React require lots of boilerplate to get going, with Svelte you just write single-file-components in vanilla javascript, with a minimal amount of Svelte-specific code. Not only does this make Svelte easier to pick-up, more importantly: the code you write can easily be used outside of Svelte. Case in point: I recently started a website for a client in Svelte, but during the project the requirements changed, and I had to port the code over to PHP. Because you just write HTML, CSS and javascript in Svelte, it was incredibly easy to port the code to another environment. If you use Mustache or Handlebars for your templates, it becomes even easier to port things over: Svelte uses Handlebars-like template tags.\n\nAs we've seen in the past: javascript frameworks come and go. While this volatile nature brings about great innovation, it also introduces uncertainty: \"Should I invest in this framework, will it still be relevant and supported in a couple of years?\". This is exactly where Svelte shines: because you just write plain html, css and javascript, there's little 'framework lock-in' in the code you write. What's more: the compiled code is vanilla javascript and does not require an external library, so that code doesn't need updating.\n\n### Get Started with Svelte\nIf you're curious to get started with Svelte, check out the [Svelte quickstart guide](https://svelte.dev/blog/the-easiest-way-to-get-started)\n","images":[{"filename":"ce9m52qvoyfuyeg09u3flj.jpg","raw":"https://raw.githubusercontent.com/dashpilot/dashpilot-website/master/content/images/ce9m52qvoyfuyeg09u3flj.jpg","title":""}],"draft":false,"category":"blog"},{"id":"72T5SY","title":"Metalsmith, build your own SSG","body":"Many static site generators have strict rules when it comes to how you should set up your site. With Metalsmith you can set everything up exactly the way you want.\n\nI’m a huge fan of static site generators, and I’ve worked with quite a few. The issue with many of them is that they’re highly opinionated: once you choose one, you have to structure your folders in a certain way, use a specific template language, and strictly format your content. If you want to do things differently, or move to a different SSG down the line, you’re out of luck.\n\nThis is what makes Metalsmith really stand out: at its core it’s basically a task runner/build script like Gulp or Webpack, and it gets all its functionality from plugins.\n\nTo get started with a base configuration, just run:\n\n```\ngit clone https://github.com/metalsmith/metalsmith.git\ncd metalsmith/examples/static-site\n```\n\nThis will install a static site example, which you can easily customize to your liking.\n\nWant to use Twig instead of Handlebars?\n```\nnpm i metalsmith-twig\n```\n\nWant to list posts based on their category?\n```\nnpm i metalsmith-collections\n```\n\nAfter you’ve installed your preferred dependancies, all you need to do is open index.json and piece it all together. This site actually runs on Metalsmith, and this was all I needed to get the site up and running:\n\n```\nMetalsmith(__dirname)\n  .source('./src')\n  .destination('./build')\n  .clean(false)\n  .use(markdown()) // I write my posts in markdown\n  .use(permalinks())\n  .use(\n    collections({ // collections allow me to group posts\n      articles: {\n        sortBy: 'date',\n        reverse: true\n      }\n    })\n  )\n  .use(layouts({\n    engine: 'handlebars' // handlebars as the template engine\n  }))\n  .use( assets( { // css and js\n          src: 'static',\n          dest: 'assets',\n          replace: 'old'\n      }))\n  .build(function(err, files) {\n    if (err) { throw err; }\n  });\n```\n\nAfter that, just run:\n```\nmake\n```\n\nThis will create a static build of your site in the “build” folder (or any other folder you defined in index.json).\n","images":[],"draft":false,"category":"blog"},{"id":"VccTMX","title":"Introduction","body":"Dashpilot is a hosted headless CMS that saves data to your own GitHub repository. Just authorize Dashpilot to access your Github account, choose a repo and start creating!\n\n## Benefits of storing data on Github\n\n### Access to a whole ecosystem\nDashpilot seemlessly fits into the whole ecosystem of static site generators, build tools, applications and hosting services that work with content and code in your Github repo. Every time you save content from Dashpilot to your Github repo, you can automatically trigger a static site generator to generate a new version of your site, and automatically trigger hosting services like Netlify or Vercel to host the latest version of your site. Dashpilot also works with Single Page Applications built with frameworks like React, Vue or Svelte, no matter if your SPA is hosted through Github or elsewhere.\n\n### No vendor lock-in, own your own data\nBecause the data is stored in your own Github Repo, you own and control your data. If you ever decide to choose switch to another CMS, there's nothing to migrate or delete and the data can be easily imported into another CMS. Dashpilot stores no information about you, so moving away is as simple as not using Dashpilot anymore.\n\n### Secure\nWhenever you log in, Dashpilot connects to your Github repo and receives a temporary access token. Once you log out (or the token expires), Dashpilot can not access your Github repo. So you're in control of when Dashpilot has access to your Github account. Furthermore, because of Github's version management features, you can always revert to a previous version of your data if anything goes wrong.\n\n### Nothing to install or update\nDashpilot is a hosted CMS, so you don't have to install or update any software.\n\n## How data is stored\nAll data will be saved as a json file, so you can use it in Single Page Apps without any additional processing or build steps. Any uploaded images are automatically resized and optimized for the web, again saving you additional conversion. To change the default image size, see [Configuration options](#3KvB5k89)","images":[],"draft":false,"category":"docs"},{"id":"DtUgnB","title":"Getting started","body":"Setting up a new site with Dashpilot is as easy as authorizing with Github, and then choosing a repo. All content you create with Dashpilot will be automatically saved to that repo.\n\n### Prerequisites\nTo get started with Dashpilot you need a Github account and at least one repository. If you don't have a Github account already, you can create a free account on (Github.com)[https://github.com]. To create a new repository, press the green 'new'-button and on the next screen choose a name, and choose 'initialize the repository with a README'. Then click 'create repository'. If you're new to Github, don't worry, this is all you need to know for now.\n","images":[],"draft":false,"category":"docs"},{"id":"3KvB5k89","title":"Configuration","body":"Apart from the options available through the Dashpilot interface, you can customize Dashpilot by creating a configuration file at the root of your repo. This allows you to configure a number of options:\n- the folder/path where your content is saved\n- the URL of your live website\n- custom fields\n\n### Creating the configuration file\n\nFirst, create a file called `dashpilot.json` at the root of your repo. The configuration file is a JSON object.\n\n### Basic options\n\n```\n{\n    \"config\": {\n        \"path\": \"public/content\", // where to store the data, default: 'content'\n        \"siteurl\": \"https://examplepage.net\" // link to your live website\n\t}\t\t\n}\n```\n\n### Custom fields\nWith custom fields you can extend Dashpilot with any extra input fields your website might need. This allows you use Dashpilot in more complex scenarios. You can also define serveral sets of custom fields (in Dashpilot such a set is called a 'layout') and users can select which set/layout to use for a particular post. Here's a basic example of a custom fields configuration which creates two layouts ('post' and 'member'), each containing two custom fields:\n\n```\n{\n    \"layouts\": [{\n        \"name\": \"post\",\n        \"fields\": [{\n            \"name\": \"subtitle\",\n            \"description\": \"subtitle\",\n            \"type\": \"text\"\n        }, {\n            \"name\": \"summary\",\n            \"description\": \"summary\",\n            \"type\": \"textarea\"\n        }],\n\t\t\"name\": \"member\",\n        \"fields\": [{\n            \"name\": \"firstname\",\n            \"description\": \"first name\",\n            \"type\": \"text\"\n        }, {\n            \"name\": \"lastname\",\n            \"description\": \"last name\",\n            \"type\": \"text\"\n        }]\n    }]\n}\n```\n\nEach custom field has three parameters:\n- name: the name of the field in the data. should not contain spaces\n- description: the description in the Dashpilot interface\n- type: the type of field, see below\n\nCurrently, there are three custom field types:\n\n- text: a single-line input field\n- textarea: a multi-line textarea\n- toggle: a true/false toggle","category":"docs","image":"","images":[],"meta":[],"draft":false}],"categories":[{"name":"default","slug":"default","fields":[]},{"name":"docs","slug":"docs"},{"name":"blog","slug":"blog"}]}